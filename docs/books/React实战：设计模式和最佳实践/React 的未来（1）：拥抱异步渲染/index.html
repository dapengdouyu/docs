<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.13">
<link rel="alternate" type="application/rss+xml" href="/rss.xml" title="Dapeng&#39;s blog RSS Feed">
<script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?7dda2565ba246ecd62878c13153e2941",e.defer=!0;var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script>
<meta name="baidu-site-verification" content="IXU12YQUjF">
<link rel="preconnect" href="https://hmcdn.baidu.com">
<link rel="stylesheet" href="https://cansiny.oss-cn-shanghai.aliyuncs.com/assets/fonts.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" integrity="sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc" crossorigin="anonymous"><title data-react-helmet="true">React 的未来（1）： 拥抱异步渲染 - Dapeng的博客</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://dapengdouyu.github.io/docs/books/React实战：设计模式和最佳实践/React 的未来（1）：拥抱异步渲染"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="React 的未来（1）： 拥抱异步渲染 - Dapeng的博客"><meta data-react-helmet="true" name="description" content="在这一节中，我们会展望一下 React 的未来，不过，在向前看之前，我们要回顾一下 React 的历史。"><meta data-react-helmet="true" property="og:description" content="在这一节中，我们会展望一下 React 的未来，不过，在向前看之前，我们要回顾一下 React 的历史。"><link data-react-helmet="true" rel="icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://dapengdouyu.github.io/docs/books/React实战：设计模式和最佳实践/React 的未来（1）：拥抱异步渲染"><link data-react-helmet="true" rel="alternate" href="https://dapengdouyu.github.io/docs/books/React实战：设计模式和最佳实践/React 的未来（1）：拥抱异步渲染" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://dapengdouyu.github.io/docs/books/React实战：设计模式和最佳实践/React 的未来（1）：拥抱异步渲染" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.978f73f5.css">
<link rel="preload" href="/assets/js/runtime~main.e2552c1f.js" as="script">
<link rel="preload" href="/assets/js/main.d3677d32.js" as="script">
</head>
<body>
<script>!function(){function e(e){document.documentElement.setAttribute("data-theme",e)}var t=function(){var e=null;try{e=localStorage.getItem("theme")}catch(e){}return e}();null!==t?e(t):window.matchMedia("(prefers-color-scheme: dark)").matches?e("dark"):(window.matchMedia("(prefers-color-scheme: light)").matches,e("light"))}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.jpg" alt="DAPENG" class="themedImage_1VuW themedImage--light_3UqQ"><img src="/img/logo.jpg" alt="DAPENG" class="themedImage_1VuW themedImage--dark_hz6m"></div><b class="navbar__title">DAPENG</b></a></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a aria-current="page" class="navbar__link" href="/">博客</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/tags/java-script">JavaScript</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" class="navbar__link">前端</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/program/javascript">Javascript</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" class="navbar__link">阅读</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/books/Babel 插件通关秘籍">Babel 插件通关秘籍</a></li></ul></div><a href="https://github.com/dapengdouyu" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>github<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_71bT toggle_3Zt9 toggleDisabled_3cF-"><div class="toggleTrack_32Fl" role="button" tabindex="-1"><div class="toggleTrackCheck_3lV7"><span class="toggleIcon_O4iE">🌜</span></div><div class="toggleTrackX_S2yS"><span class="toggleIcon_O4iE">🌞</span></div><div class="toggleTrackThumb_xI_Z"></div></div><input type="checkbox" class="toggleScreenReader_28Tw" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_35hR" type="button"></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_2fq0" href="/docs/books/Babel 插件通关秘籍/">Babel 插件通关秘籍</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_2fq0" href="/docs/books/MySQL 是怎样运行的：从根儿上理解 MySQL/">MySQL 是怎样运行的：从根儿上理解 MySQL</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_2fq0" href="/docs/books/React Hooks 与 Immutable 数据流实战/">React Hooks 与 Immutable 数据流实战</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_2fq0" href="/docs/books/React 组合式开发实践：打造企业管理系统五大核心模块/">React 组合式开发实践：打造企业管理系统五大核心模块</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active hasHref_2fq0" href="/docs/books/React实战：设计模式和最佳实践/">React实战：设计模式和最佳实践</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/books/React实战：设计模式和最佳实践/">index</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/books/React实战：设计模式和最佳实践/React 单元测试">React 单元测试</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/books/React实战：设计模式和最佳实践/React 状态管理（1）：组件状态">React 状态管理（1）：组件状态</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/books/React实战：设计模式和最佳实践/React 状态管理（2）：Redux 使用模式">React 状态管理（2）：Redux 使用模式</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/books/React实战：设计模式和最佳实践/React 状态管理（3）：Mobx  使用模式">React 状态管理（3）：Mobx 使用模式</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/books/React实战：设计模式和最佳实践/React 状态管理（4）：不同方式对比">React 状态管理（4）：不同方式对比</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/books/React实战：设计模式和最佳实践/React 的未来（1）：拥抱异步渲染">React 的未来（1）： 拥抱异步渲染</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/books/React实战：设计模式和最佳实践/React 的未来（2）：Suspense 带来的异步操作革命">React 的未来（2）：Suspense 带来的异步操作革命</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/books/React实战：设计模式和最佳实践/React 的未来（3）：函数化的 Hooks">React 的未来（3）：函数化的 Hooks</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/books/React实战：设计模式和最佳实践/React 的设计思想">React 的设计思想</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/books/React实战：设计模式和最佳实践/服务器端渲染（1）：基本套路">服务器端渲染（1）：基本套路</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/books/React实战：设计模式和最佳实践/服务器端渲染（2）：理解 Next、js">服务器端渲染（2）：理解 Next.js</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/books/React实战：设计模式和最佳实践/组件实践（1）：如何定义清晰可维护的接口">组件实践（1）：如何定义清晰可维护的接口</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/books/React实战：设计模式和最佳实践/组件实践（2）：组件的内部实现">组件实践（2）：组件的内部实现</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/books/React实战：设计模式和最佳实践/组件实践（3）：组件化样式">组件实践（3）：组件化样式</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/books/React实战：设计模式和最佳实践/组件设计模式（1）：聪明组件和傻瓜组件">组件设计模式（1）：聪明组件和傻瓜组件</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/books/React实战：设计模式和最佳实践/组件设计模式（2）：高阶组件">组件设计模式（2）：高阶组件</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/books/React实战：设计模式和最佳实践/组件设计模式（3）：render props 模式">组件设计模式（3）：render props 模式</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/books/React实战：设计模式和最佳实践/组件设计模式（4）： 提供者模式">组件设计模式（4）：提供者模式</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/books/React实战：设计模式和最佳实践/组件设计模式（5）：组合组件">组件设计模式（5）：组合组件</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/books/React实战：设计模式和最佳实践/结语">结语</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/books/React实战：设计模式和最佳实践/路由的魔法：React Router">路由的魔法：React Router</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_2fq0" href="/docs/books/Taro 多端开发实现原理与项目实战/">Taro 多端开发实现原理与项目实战</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_2fq0" href="/docs/books/前端性能优化原理与实践/">前端性能优化原理与实践</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_2fq0" href="/docs/books/前端面试之道/">前端面试之道</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_2fq0" href="/docs/books/微信小程序开发入门：从 0 到 1 实现天气小程序/">微信小程序开发入门：从 0 到 1 实现天气小程序</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_2fq0" href="/docs/books/正则表达式/">正则表达式</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_2fq0" href="/docs/books/深入浅出TypeScript：从基础知识到类型编程/">深入浅出TypeScript：从基础知识到类型编程</a></div></li></ul></nav><button type="button" title="Collapse sidebar" aria-label="Collapse sidebar" class="button button--secondary button--outline collapseSidebarButton_1CGd"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_3E-R"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="tocCollapsible_1PrD theme-doc-toc-mobile tocMobile_3Hoh"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>React 的未来（1）： 拥抱异步渲染</h1></header><p>在这一节中，我们会展望一下 React 的未来，不过，在向前看之前，我们要回顾一下 React 的历史。</p><h2 class="anchor anchorWithStickyNavbar_31ik" id="react-简史">React 简史<a aria-hidden="true" class="hash-link" href="#react-简史" title="Direct link to heading">​</a></h2><p>React 最初是 Facebook 的一个内部项目，投入实际产品是在 2011 年，用于 Facebook 的时间线界面，随后，Facebook 在其收购的 Instagram 中也使用了这种技术，2013 年 5 月，Facebook 决定将 React 开源。</p><p>有很长一段时间，React 一直是以 0.x.x 的模式来增长版本，大版本是 0，只有小版本和补丁版本迭代。直到 2016 年 4 月，React 经过这么长时间产品环境的磨练，已经足够成熟，所以版本一下子从 v0.14.8 跳到了 v15.0.0。其实这种版本改变的模式对开发者并没有什么直接影响，但是反映了 Facebook 致力于 React 开发的决心。</p><p>到了 v16.0.0 的时候，React 有一个重大改变——核心代码被重写，引入了叫 <a href="https://zhuanlan.zhihu.com/p/26027085" target="_blank" rel="noopener noreferrer">Fiber</a> 这个全新的架构。这个架构使得 React 用异步渲染成为可能，但要注意，这个改变只是让异步渲染（async rendering）成为“可能”，React 却并没有在 v16 发布的时候立刻开启这种“可能”，也就是说，React 在 v16 发布之后依然使用的是同步渲染。不过，虽然异步渲染没有立刻采用，Fiber 架构还是打开了通向新世界的大门，React v16 一系列新功能几乎都是基于 Fiber 架构。</p><p>要面向 React 未来，我们首先要理解这个异步渲染的概念。</p><h2 class="anchor anchorWithStickyNavbar_31ik" id="同步渲染的问题">同步渲染的问题<a aria-hidden="true" class="hash-link" href="#同步渲染的问题" title="Direct link to heading">​</a></h2><p>长期以来，React 一直用的是同步渲染，这样对 React 实现非常直观方便，但是会带来性能问题。</p><p>假设有一个超大的 React 组件树结构，有 1000 个组件，每个组件平均使用 1 毫秒，那么，要做一次完整的渲染就要花费 1000 毫秒也就是 1 秒钟，然而 JavaScript 运行环境是单线程的，也就是说，React 用同步渲染方式，渲染最根部组件的时候，会同步引发渲染子组件，再同步渲染子组件的子组件……最后完成整个组件树。在这 1 秒钟内，同步渲染霸占 JavaScript 唯一的线程，其他的操作什么都做不了，在这 1 秒钟内，如果用户要点击什么按钮，或者在某个输入框里面按键，都不会看到立即的界面反应，这也就是俗话说的“卡顿”。</p><p>在同步渲染下，要解决“卡顿”的问题，只能是尽量缩小组件树的大小，以此缩短渲染时间，但是，应用的规模总是在增大的，不是说缩小就能缩小的，虽然我们利用定义 shouldComponentUpdate 的方法可以减少不必要的渲染，但是这也无法从根本上解决大量同步渲染带来的“卡顿”问题。</p><h3 class="anchor anchorWithStickyNavbar_31ik" id="异步渲染两阶段渲染">异步渲染：两阶段渲染<a aria-hidden="true" class="hash-link" href="#异步渲染两阶段渲染" title="Direct link to heading">​</a></h3><p>React Fiber 引入了异步渲染，有了异步渲染之后，React 组件的渲染过程是分时间片的，不是一口气从头到尾把子组件全部渲染完，而是每个时间片渲染一点，然后每个时间片的间隔都可去看看有没有更紧急的任务（比如用户按键），如果有，就去处理紧急任务，如果没有那就继续照常渲染。</p><p>根据 React Fiber 的设计，一个组件的渲染被分为两个阶段：第一个阶段（也叫做 render 阶段）是可以被 React 打断的，一旦被打断，这阶段所做的所有事情都被废弃，当 React 处理完紧急的事情回来，依然会重新渲染这个组件，这时候第一阶段的工作会重做一遍；第二个阶段叫做 commit 阶段，一旦开始就不能中断，也就是说第二个阶段的工作会稳稳当当地做到这个组件的渲染结束。</p><p>两个阶段的分界点，就是 <code>render</code> 函数。render 函数之前的所有生命周期函数（包括 render)都属于第一阶段，之后的都属于第二阶段。</p><p>开启异步渲染，虽然我们获得了更好的感知性能，但是考虑到第一阶段的的生命周期函数可能会被重复调用，不得不对历史代码做一些调整。</p><p>在 React v16.3 之前，render 之前的生命周期函数（也就是第一阶段生命周期函数）包括这些：</p><ul><li>componentWillReceiveProps</li><li>shouldComponentUpdate</li><li>componentWillUpdate</li><li>componentWillMount</li><li>render</li></ul><p>下图是 React v16.3 之前的完整的生命周期函数图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/14/1670f0f2d4d06575?w=2000&amp;h=924&amp;f=png&amp;s=162934" alt="React Lifecycle before v16.3"></p><p>React 官方告诫开发者，虽然目前所有的代码都可以照常使用，但是未来版本中会废弃掉，为了将来，使用 React 的程序应该快点去掉这些在第一阶段生命函数中有副作用的功能。不得不说 React 真的很够意思，提前这么久告诉大家这个事情，让大家有足够的时间去修改自己的代码。</p><p>一个典型的错误用例，也是我被问到做多的问题之一：为什么不在 componentWillMount 里去做AJAX？componentWillMount 可是比 componentDidMount 更早调用啊，更早调用意味着更早返回结果，那样性能不是更高吗？</p><p>首先，一个组件的 componentWillMount 比 componentDidMount 也早调用不了几微秒，性能没啥提高；而且，等到异步渲染开启的时候，componentWillMount 就可能被中途打断，中断之后渲染又要重做一遍，想一想，在 componentWillMount 中做 AJAX 调用，代码里看到只有调用一次，但是实际上可能调用 N 多次，这明显不合适。相反，若把 AJAX 放在 componentDidMount，因为 componentDidMount 在第二阶段，所以绝对不会多次重复调用，这才是 AJAX 合适的位置（当然，React 未来有更好的办法，在下一小节 Suspense 中可以讲到）。</p><h3 class="anchor anchorWithStickyNavbar_31ik" id="getderivedstatefromprops">getDerivedStateFromProps<a aria-hidden="true" class="hash-link" href="#getderivedstatefromprops" title="Direct link to heading">​</a></h3><p>到了 React v16.3，React 干脆引入了一个新的生命周期函数 getDerivedStateFromProps，这个生命周期函数是一个 static 函数，在里面根本不能通过 <code>this</code> 访问到当前组件，输入只能通过参数，对组件渲染的影响只能通过返回值。没错，getDerivedStateFromProps 应该是一个纯函数，React 就是通过要求这种纯函数，强制开发者们必须适应异步渲染。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly javascript"><pre tabindex="0" class="prism-code language-javascript codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">static</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">getDerivedStateFromProps</span><span class="token punctuation" style="color:#393A34">(</span><span class="token parameter">nextProps</span><span class="token parameter punctuation" style="color:#393A34">,</span><span class="token parameter"> prevState</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic">//根据nextProps和prevState计算出预期的状态改变，返回结果会被送给setState</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>到了 React v16.3，React 生命周期函数全图如下:</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/14/1670f0fc08e10440?w=1674&amp;h=917&amp;f=jpeg&amp;s=161235" alt="React Lifecycle in v16.3"></p><p>注意，上图中并包含全部React生命周期函数，在React v16发布时，还增加了一个<code>componentDidCatch</code>，当异常发生时，一个可以捕捉到异常的<code>componentDidCatch</code>就排上用场了。不过，很快React觉着这还不够，在v16.6.0又推出了一个新的捕捉异常的生命周期函数<code>getDerivedStateFromError</code>。</p><p>如果异常发生在第一阶段（render阶段），React就会调用<code>getDerivedStateFromError</code>，如果异常发生在第二阶段（commit阶段），React会调用<code>componentDidCatch</code>。这个区别也体现出两个阶段的区分对待。</p><h3 class="anchor anchorWithStickyNavbar_31ik" id="适应异步渲染的组件原则">适应异步渲染的组件原则<a aria-hidden="true" class="hash-link" href="#适应异步渲染的组件原则" title="Direct link to heading">​</a></h3><p>明白了异步渲染的来龙去脉之后，开发者就应该明白，现在写代码必须要为未来的某一次 React 版本升级做好准备，当 React 开启异步渲染的时候，你的代码应该做到在 render 之前最多只能这些函数被调用：</p><ul><li>构造函数</li><li>getDerivedStateFromProps</li><li>shouldComponentUpdate</li></ul><p>幸存的这些第一阶段函数，除了构造函数，其余两个全都必须是纯函数，也就是不应该做任何有副作用的操作。</p><p>实际上，如果之前你的用法规范，除了 shouldComponentUpdate 不怎么使用第一阶段生命周期函数，你还会发现不怎么需要改动代码，比如 componentWillMount 中的代码移到构造函数中就可以了。但是如果用法错乱，比如滥用componentWillReceiveProps，那就不得不具体情况具体分析，从而决定这些代码移到什么位置。</p><p>开发者中一个普遍的误区，就是总想把任务往前提，提到靠前的生命周期函数去，就像我前面说过的在 componentWillMount 中做 AJAX。正确的做法是根据各函数的语义来放置代码，并不是越往前越好。</p><h2 class="anchor anchorWithStickyNavbar_31ik" id="小结">小结<a aria-hidden="true" class="hash-link" href="#小结" title="Direct link to heading">​</a></h2><p>这一小节我们介绍了 React v16 引入的“异步渲染”，读者通过本节阅读应该能够理解：</p><ol><li>异步渲染的意义；</li><li>理解两阶段渲染；</li><li>为了应对异步渲染，我们开发 React 组件需要对生命周期函数做哪些调整。</li></ol></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/dapengdouyu/docs/tree/master/docs/books/React实战：设计模式和最佳实践/React 的未来（1）：拥抱异步渲染.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_13-_"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/books/React实战：设计模式和最佳实践/React 状态管理（4）：不同方式对比"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« <!-- -->React 状态管理（4）：不同方式对比</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/books/React实战：设计模式和最佳实践/React 的未来（2）：Suspense 带来的异步操作革命"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">React 的未来（2）：Suspense 带来的异步操作革命<!-- --> »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#react-简史" class="table-of-contents__link toc-highlight">React 简史</a></li><li><a href="#同步渲染的问题" class="table-of-contents__link toc-highlight">同步渲染的问题</a><ul><li><a href="#异步渲染两阶段渲染" class="table-of-contents__link toc-highlight">异步渲染：两阶段渲染</a></li><li><a href="#getderivedstatefromprops" class="table-of-contents__link toc-highlight">getDerivedStateFromProps</a></li><li><a href="#适应异步渲染的组件原则" class="table-of-contents__link toc-highlight">适应异步渲染的组件原则</a></li></ul></li><li><a href="#小结" class="table-of-contents__link toc-highlight">小结</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 dapeng (张亚鹏)  <a href="https://beian.miit.gov.cn/#/Integrated/index">京ICP备20028300号</a></div></div></div></footer></div>
<script src="/assets/js/runtime~main.e2552c1f.js"></script>
<script src="/assets/js/main.d3677d32.js"></script>
</body>
</html>