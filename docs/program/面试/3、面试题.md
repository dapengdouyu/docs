# Promise 的优点

## 1. JS 实现一个带并发限制的异步调度器 Scheduler，保证同时运行的任务最多有`两个`。完善下面代码的 Scheduler 类，使以下程序能够正常输出：

```js
class Scheduler {
  constructor() {
    this.listener = [];
    this.max = 3;
    this.timer = null;
  }
  //   收集依赖
  add(promiseCreator) {
    this.listener.push(promiseCreator);
    if (this.timer) {
      clearTimeout(this.timer);
    }
    this.timer = setTimeout(() => {
      this.request();
    });
  }
  request(count = 0) {
    const l = this.listener.shift();
    if (typeof l === "function") {
      l().then(() => {
        this.request(count - 1);
      });
    }
    if (count++ < this.max) {
      this.request(count + 1);
    }
  }
}

const timeout = (time) =>
  new Promise((resolve) => {
    setTimeout(resolve, time);
  });

const scheduler = new Scheduler();

const addTask = (time, order) => {
  scheduler.add(() => timeout(time).then(() => console.log(order)));
};

addTask(1000, "1");
addTask(500, "2");
addTask(300, "3");
addTask(400, "4");
addTask(400, "5");

// output: 2 3 1 4
```

## 2. 实现下面的方法,使其结果为 1200

### 2.1 通过 reduce 实现

```js
function p1(a) {
  return new Promise((resolve, reject) => {
    resolve(a * 5);
  });
}
function p2(a) {
  return new Promise((resolve, reject) => {
    resolve(a * 2);
  });
}
function f3(a) {
  return a * 3;
}
function p4(a) {
  return new Promise((resolve, reject) => {
    resolve(a * 4);
  });
}

const promiseArr = [p1, p2, f3, p4];
runPromiseInSequence(promiseArr, 10).then(console.log);

function runPromiseInSequence(arr, init) {
  return arr.reduce((memo, next) => {
    return memo.then(next);
  }, Promise.resolve(init));
}
```

### 2.2 通过 async 和 await 实现

```js
async function runPromiseInSequence(arr, init) {
  for (let item of arr) {
    init = await item(init);
  }
  return init;
}
```

## 3. 柯里化

> 占存数据，返回一个新函数，当最后一次调用函数的时候才返回值

### 3.1 有长度的

```js
function curry(callback) {
  let cache = [];
  return function fn(...args) {
    cache = cache.concat(args);
    if (cache.length >= callback.length) {
      callback.apply(this, cache);
    }
    return fn;
  };
}
```

### 3.2 没有长度的

```js
function curry(callback) {
  let cache = [];
  function fn(...args) {
    cache = cache.concat(args);
    return fn;
  }
  fn.toString = function () {
    return callback.apply(this, cache);
  };
  return fn;
}
```

## 4. call 和 apply 的区别是什么，哪个性能更好一些

- 都是可以修改 this 的指向，并且执行函数
- call 是参数一个一个的传递
- [apply](https://tc39.es/ecma262/#sec-function.prototype.apply) 是参数是一个数组
- [call](https://jsperf.com/call-apply-segu) 的性能更好,apply 调用的就是`call`

### 4.1 实现 call

- 将函数设为对象的属性
- 执行该函数
- 删除该函数

```js
Function.prototype.call = function (context, ...args) {
  context = context || window;
  const fn = Symbol();
  context[fn] = this;
  const ret = context[fn](...args);
  delete context[fn];
  return ret;
};
```

### 4.2 实现 apply

```js
Function.prototype.apply = function (context, args) {
  context = context || window;
  const fn = Symbol();
  context[fn] = this;
  const ret = context[fn](...args);
  delete context[fn];
  return ret;
};
```

### 4.3 面试题

```js
function fn1() {
  console.log(1);
}
function fn2() {
  console.log(2);
}
fn1.call.call(fn2);
/**
 * 解析：
 * 1、fn1.call=== call函数1
 * 2. call函数1.call执行
 * 3. context[fn]=call函数1 ===> fn2.call函数1执行
 * 4. fn2.call()执行
 * 5. 所以fn2执行
 *
 */
```

## 5. 数组里面有 10w 条数据，取第一个和第 10w 个元素的时间相差多少?

一样的

## 6. 编写 parse 函数，实现访问对象里属性的值

### 6.1 简单一版实现

```js
let obj = { a: 1, b: { c: 2 }, d: [1, 2, 3], e: [{ f: [4, 5, 6] }] };
let r1 = parse(obj, "a"); // = 1;
let r2 = parse(obj, "b.c"); // = 2;
let r3 = parse(obj, "d[2]"); // = 3;
let r4 = parse(obj, "e[0].f[2]"); // = 4;
function parse(obj, str) {
  return new Function("obj", "return obj." + str.replace(/\.(\d+)/g, "[$1]"))(
    obj
  );
}
```

### 6.2 面试版

```js
let obj = { a: 1, b: { c: 2 }, d: [1, 2, 3], e: [{ f: [4, 5, 6] }] };
let r1 = parse(obj, "a"); // = 1;
let r2 = parse(obj, "b.c"); // = 2;
let r3 = parse(obj, "d[2]"); // = 3;
let r4 = parse(obj, "e[0].f[2]"); // = 4;

function parse(obj, str) {
  return str
    .split(/[\.\[\]]/g)
    .filter((l) => l !== "")
    .reduce((memo, next, index, arr) => {
      if (memo == null && arr.length - 1 !== index) {
        memo = {};
      }
      return memo[next];
    }, obj);
}
```

## 7.数组扁平化 flat 方法的多种实现？

### 7.1 es6

```js
let arr = [[1], [2, 3], [4, 5, 6, [7, 8, [9, 10, [11]]]], 12];
let flattedArr = arr.flat(Infinity);
console.log(flattedArr);
```

### 7.2 toString

**缺点**:会改变数组的类型

```js
let arr = [[1], [2, 3], [4, 5, 6, [7, 8, [9, 10, [11]]]], 12];
console.log(
  arr
    .toString()
    .split(",")
    .map((item) => Number(item))
);
```

### 7.3 stringify

```js
JSON.stringify(arr)
  .split(/[\[\],]/g)
  .filter((item) => item !== "")
  .map((item) => Number(item));
```

### 7.4 while

```js
while (arr.some((item) => Array.isArray(item))) {
  arr = [].concat(...arr);
}
```

### 7.5 递归

```js
function flat(arr, r = []) {
  if (!Array.isArray(arr)) {
    return arr;
  }
  for (let item of arr) {
    r = r.concat(flat(item));
  }
  return r;
}
```

## 9. 题目描述:实现一个 `compose` 函数

### 9.1 用法如下:

```js
// 用法如下:
function fn1(x) {
  return x + 1;
}
function fn2(x) {
  return x + 2;
}
function fn3(x) {
  return x + 3;
}
function fn4(x) {
  return x + 4;
}
const a = compose(fn1, fn2, fn3, fn4);
console.log(a(1)); // 1+4+3+2+1=11
```

### 9.2 实现代码如下:

```js
function compose() {}
```

## 10. 实现`12345678.002345 -> 12,345,678.002345`

```js

```

## 11. 下列的结果是

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <button id="btn">btn</button>
    <script>
      const btn = document.getElementById("btn");
      btn.addEventListener("click", () => {
        console.log("c1");
        Promise.resolve().then(() => console.log("p1"));
      });
      btn.addEventListener("click", () => {
        console.log("c2");
        Promise.resolve().then(() => console.log("p2"));
      });
      btn.click();
      console.log(3);
    </script>
  </body>
</html>
```

- 直接调用 click 是同步的，如果手动点击是宏任务
- 所以首次结果是:`c1 c2 3 p1 p2`
- 手动点击的结果是:`3 c1 p1 c2 p2`

## 12. 下列的结果是

```js
async function f1() {
  return new Promise((resolve) => {
    console.log(4);
    resolve();
  }).then(() => {
    console.log(5);
  });
}
async function run() {
  console.log(1);
  new Promise((resolve) => {
    console.log(2);
    resolve();
  }).then(() => {
    console.log(3);
  });
  await f1();
  setTimeout(() => {
    console.log(6);
  }, 0);
  console.log(7);
}
run();
// 1 2 4 3 5 7 6
```

## 13.把数字"312345678"，变成 "312,345,678"。

```js
function parse(number) {
  return (number + "").replace(/(?!^)(?=(\d{3})+$)/g, ",");
}
```

## 14.写一个程序，解析下面的 queryString,返回对象

### test

```js
console.log(parse("a=1&b=2&c=3"));
console.log(parse("a&b&c"));
console.log(parse("a[name]=yl&a[age]=20&b[age]=2&c=3"));
console.log(parse("color=deep%20blue"));
console.log(parse("a[0]=1&a[1]=2"));
```

### 实现

```js
function parse(url) {
  return url.split("&").reduce((memo, next) => {
    const [key, value] = next.split("=");
    if (!value) return memo;
    const path = key.split(/[\[\]\.]/).filter((item) => item !== "");
    deep_set(memo, path, value);
    return memo;
  }, {});
}
function deep_set(memo, path, value) {
  path.reduce((obj, key, index, arr) => {
    if (index === arr.length - 1) {
      obj[key] = decodeURIComponent(value);
    } else {
      if (obj[key] == null) {
        if (arr[index + 1].match(/^\d+$/)) {
          obj[key] = [];
        } else {
          obj[key] = {};
        }
      }
    }
    return obj[key];
  }, memo);
}
```

## 15、下面程序的结果

![优先级](/img/刷题/7.png)

```js
function Foo() {
  getName = function () {
    console.log(1);
  };
  return this;
}
Foo.getName = function () {
  console.log(2);
};
Foo.prototype.getName = function () {
  console.log(3);
};
var getName = function () {
  console.log(4);
};
function getName() {
  console.log(5);
}

Foo.getName();
getName();
Foo().getName();
getName();
new Foo.getName();
new Foo().getName();
new new Foo().getName();

//2 4 1 1 2 3 3
```

## 16、实现 bind

- 用法

```js
function a() {
  console.log(this.a); //1
}
a.bind({ a: 1 })();
```

- 实现

```js
Function.prototype.bind = function (context, ...args) {
  // 调用 bind 的不是函数咋办？
  if (typeof this !== "function") {
    throw new Error("必须是函数调用");
  }
  const self = this;
  context = context || window;
  function bound() {
    args = args.concat([].slice.call(arguments));
    self.apply(this instanceof bound ? this : context, args);
  }
  // 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值
  bound.prototype = Object.create(this.prototype);
  return bound;
};
```

## 17. Object.create 的实现

- 用法

```js
const a = { a: 1 };
console.log(
  Object.create(a, {
    c: { value: 1 },
  })
);
/*
*{c:1,
*__proto__:{
* a:1
*}
*/
}
```

- 实现
  > `Object.create` 其实就是创建一个空对象, 将该对象的原型设置为传入的参数

```js
function create(context, propertiesObject = {}) {
  function Fn() {}
  Fn.prototype = context;
  return Object.defineProperties(new Fn(), propertiesObject);
}
```

## 18.new 的实现

1. 创建一个空对象
2. 将构造函数的原型赋值给该对象
3. 执行构造函数，并将构造函数的 this 设置成空对象
4. 看构造函数的返回值是什么类型，如果是引用类型，将返回值作为该构造函数的实例
5. 如果是值类型,将对象作为构造函数的实例

```js
 function new(){
   const Constructor=[].shift.call(arguments);
    const obj=Object.create(Constructor.prototype);
    const returnObj=Constructor.apply(obj,[].slice.call(arguments));
    return typeof returnObj==='object'?returnObj:obj;
 }
```

## 19.instanceof

> 右边构造函数的 prototype,在左边对象的原型的原型链上

- 使用

```js
"1" instanceof String;
```

- 实现

```js
function instanceof(left,right){
  let result=left.__proto__;
  // 若找不到就到一直循环到父类型或祖类型
  while(result!=null){
    if(result===right.prototype){
      return true;
    }
    result=result.__proto__//// 获取祖类型的__proto__
  }
  return false
}
```

## 20.实现 Array.prototype.reduce

- 使用

```js
let arr = [{ name: 1 }, { name: 2 }, { name: 3 }];
arr.reduce((memo, item, index, arr) => {
  console.log(index); //1
  return memo + item.name;
});
```

- 实现

```js
Array.prototype.reduce = function (callback, initValue) {
  if (typeof callback !== "function") {
    throw new TypeError(`callback必须是函数`);
  }
  // 如果不是数组直接返回
  if (!Array.isArray(this) || this.length === 0) return;
  let arr = this,
    hasInitValue = init != null;
  initValue = hasInitValue ? initValue : this[0];
  for (let i = hasInitValue ? 0 : 1; i < arr.length; i++) {
    initValue = callback(initValue, arr[i], i, arr);
  }
  return initValue;
};
```

## 21.Array.prototype.filter 的实现

- 使用

```js
let arr = [{ name: 1 }, { name: 2 }, { name: 3 }];
arr.filter((item, index, arr) => {
  return item === 1;
});
```

- 实现

```js
Array.prototype.filter = function (callback) {
  if (typeof callback !== "function") {
    throw new TypeError(`callback必须是函数`);
  }
  if (Array.isArray(this) || this.length === 0) return;
  const result = [];
  for (let i = 0; i < this.length; i++) {
    const ret = callback(this[i], i, this);
    if (ret) {
      result.push(ret);
    }
  }
  return result;
};
```

## 22. Array.prototype.map 的实现

- 使用

```js
Array.prototype.map = function (callback) {
  if (typeof callback !== "function") {
    throw new TypeError(`callback必须是函数`);
  }
  if (Array.isArray(this) || this.length === 0) return;
  const result = [];
  for (let i = 0; i < this.length; i++) {
    result[i] = callback(this[i], i, this);
  }
  return result;
};
```

## 23. 数组去重的方法

- es6

```js
function unique(arr) {
  return [...new Set(arr)];
}
```

- 对象

```js
function unique(arr) {
  let obj = {},
    r = [];
  for (let item of arr) {
    if (!obj[item]) {
      r.push(item);
      obj[item] = true;
    }
  }
  return r;
}
```

## 24. 求数组的交集

```js
function unique(arr1, arr2) {
  return [...new Set(arr1)].filter((item) => new Set(arr2).has(item));
}
```

## 25. 求数组的并集

```js
function union(arr1, arr2) {
  return [...new Set(arr1), ...new Set(arr2)];
}
```

## 26. 求数组的差集

```js
function diff(arr1, arr2) {
  let s1 = new Set(arr1);
  let s2 = new Set(arr2);
  return [...s1, ...s2].filter((item) => !s1.has(item) || !s2.has(item));
}
```

## 27. [洗牌算法](https://www.jianshu.com/p/e7edc1641d30)

> sort 升序:a-b 降序:b-a

```js
var arr = [1, 2, 3, 4];
arr.sort((item) => Math.random > 0.5);
```

### 真实的

```js
Array.prototype.shuffle = function () {
  let arr = this,
    len = arr.length;
  for (let i = len - 1; i > 0; i--) {
    let g = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[g]] = [arr[g], arr[i]];
  }
};
```

## 28. deepClone

- 使用

```js
let obj = {
  a: 1,
  b: { c: 2 },
  fn: function () {
    console.log("fn");
  },
  RegExp: new RegExp(/\d/g),
  date: new Date(),
  arr: [1, 2],
  s: Symbol("s"),
};
obj.obj = obj;
let obj1 = deepClone(obj);
console.log(obj1);
console.log(obj1.s === obj.s);
```

- 实现

```js
function deepClone(source, cache = new WeakMap()) {
  if (typeof source === "symbol") {
    return source;
  }
  if (typeof source !== "object") {
    return source;
  }
  if (cache.has(source)) {
    return cache.get(source);
  }
  if (source instanceof RegExp) {
    return new RegExp(source);
  }
  if (source instanceof Date) {
    return new Date(source);
  }
  let target = new source.__proto__.constructor();
  cache.set(source, target);
  for (let key in source) {
    if (source.hasOwnProperty(key)) {
      target[key] = deepClone(source[key],cache);
    }
  }
  return target;
}
```

##

```js
const list = [
  {
    id: 2,
    text: '节点1_1',
    parentId: 1 //通过这个字段来确定子父级
  },
  {
      id: 1,
      text: '节点1',
      parentId: 0 //这里用0表示为顶级节点
  },
]

/**
 * 转成
[
  {
      id: 1,
      text: '节点1',
      parentId: 0,
      children: [
          {
              id:2,
              text: '节点1_1',
              parentId:1
          }
      ]
  }
]
 */
```

```js
function parse(arr,obj={},result=[]){
  for(let item of arr){
    obj[item.id]=item;
  }
  for(let item of arr){
      const id=item.id,parentId=item.parentId;
      obj[parentId].children=[...obj[parentId].children,item];
  }
}
```