# 条件类型

> 条件类型:类似`js`的三元表达式
> `extends` 是`包含`的意思

## 条件类型基本使用

可以使用 **extends** 关键字和`三元表达式`，实现`条件判断`

```ts
interface Fish {
  name1: string;
}
interface Water {
  name2: string;
}
interface Bird {
  name3: string;
}
interface Sky {
  name4: string;
}
type Condition<T> = T extends Fish ? Water : Sky;
let con1: Condition<Fish> = { name2: "水" };
```

## 条件类型分发

```ts
let con2: Condition<Fish | Bird> = { name2: "水" };
```

这里会用每一项依次进行`分发`,最终采用联合类型作为结果,等价于:

```ts
type c1 = Condition<Fish>;
type c2 = Condition<Bird>;
type c = c1 | c2;
```

# 内置条件类型

> 作用于`联合`类型

## `Exclude` 排除类型

```ts
// extends是包含的意思
type Exclude<T, U> = T extends U ? never : T;
type MyExclude = Exclude<"1" | "2" | "3", "1" | "2">;
```

## `Extract` 抽取类型

```ts
type Extract<T, U> = T extends U ? T : never;
type MyExtract = Extract<"1" | "2" | "3", "1" | "2">;
```

## `NoNullable` 非空检测

去除联合类型的`空值`

```ts
type NonNullable<T> = T extends null | undefined ? never : T;
type MyNone = NonNullable<"a" | null | undefined>;
```

## infer 类型推断

### `ReturnType`返回值类型

```ts
function getUser(a: number, b: number) {
  return { name: "大鹏", age: 10 };
}
type ReturnType<T> = T extends (...args: any) => infer R ? R : never;
type MyReturn = ReturnType<typeof getUser>;
```

### `Parameters` 参数类型

```ts
type Parameters<T> = T extends (...args: infer R) => any ? R : any;
type MyParams = Parameters<typeof getUser>;
```

### `ConstructorParameters`构造函数参数类型

```ts
class Person {
  constructor(name: string, age: number) {}
}
type ConstructorParameters<T> = T extends { new (...args: infer R): any }
  ? R
  : never;
type MyConstructor = ConstructorParameters<typeof Person>;
```

### `InstanceType` 实例类型

```ts
type InstanceType<T> = T extends { new (...args: any): infer R } ? R : any;
type MyInstance = InstanceType<typeof Person>;
```

## infer 实践

### 将数组类型转化为联合类型

```ts
type ElementOf<T> = T extends Array<infer E> ? E : never;
type TupleToUnion = ElementOf<[string, number, boolean]>;
```

### 将两个函数的参数转化为交叉类型

```ts
type T1 = { name: string };
type T2 = { age: number };
type ToIntersection<T> = T extends [(x: infer U) => any, (x: infer U) => any]
  ? U
  : never;
type t3 = ToIntersection<[(x: T1) => any, (x: T2) => any]>;
```

> 表示要把 `T1`、`T2` 赋予给 `x`，那么`x` 的值就是 `T1`、`T2` 的交集。（参数是逆变的可以传父类）
> TS 的类型：`TS` 主要是为了代码的安全性来考虑。所以所有的兼容性问题都要从**安全性**来考虑!
