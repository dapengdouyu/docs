## eval

eval 方法就像是一个完整的 `ECMAScript 解析器`，它只接受一个参数，即要执行的 `ECMAScript（或 JavaScript）`

```js
eval("alert('hi')");
```

这行代码的作用等价于下面这行代码：

```js
alert("hi");
```

当解析器发现代码中调用 `eval()`方法时，它会将传入的参数当作实际的 `ECMAScript 语句`来解析，
然后把`执行结果插入到原位置`。通过 eval()执行的代码被认为是包含该次调用的`执行环境`的一部分，
因此被执行的代码具有与该`执行环境相同`的作用域链。这意味着通过`eval()`执行的代码可以引用在包
含环境中定义的变量，举个例子：

```js
var msg = "hello world";
eval("alert(msg)"); //"hello world"
```

可见，变量 `msg` 是在 `eval()`调用的环境之外定义的，但其中调用的 `alert()`仍然能够显示"hello
world"。这是因为上面第二行代码最终被替换成了一行真正的代码。同样地，我们也可以在 `eval()`
调用中定义一个函数，然后再在该调用的外部代码中引用这个函数：

```js
eval("function sayHi() { alert('hi'); }");
sayHi();
```

显然，函数 `sayHi()`是在 `eval()`内部定义的。但由于对`eval()`的调用最终会被替换成定义函数
的实际代码，因此可以在下一行调用 `sayHi()`。对于变量也一样：

```js
val("var msg = 'hello world'; ");
alert(msg); //"hello world"
```

在`eval()`中创建的任何变量或函数都不会被提升，因为在解析代码的时候，它们被包含在一个字
符串中；它们只在 `eval()`执行的时候创建。

`严格模式下`，在外部访问不到`eval()`中创建的任何变量或函数，因此前面两个例子都会导致错误。
同样，在`严格模式`下，为 `eval 赋值`也会导致错误：

```js
"use strict";
eval = "hi"; //causes error
```

饱受诟病的 `eval()`函数在严格模式下也得到了提升。最大的变化就是它在包含上下文中不再创建
变量或函数。例如：

```js
//使用 eval()创建变量
//非严格模式：弹出对话框显示 10
//严格模式：调用 alert(x)时会抛出 ReferenceError
function doSomething() {
  eval("var x=10");
  alert(x);
}
```

如果是在非严格模式下，以上代码会在函数 `doSomething()`中创建一个局部变量 x，然后 alert()
还会显示该变量的值。但在严格模式下，在 doSomething()函数中调用 eval()不会创建变量 x，因此
调用 alert()会导致抛出 `ReferenceError`，因为 x 没有定义。

可以在 `eval()`中声明变量和函数，但这些变量或函数只能在被求值的特殊作用域中有效，随后就
将被销毁。因此，以下代码可以运行，没有问题

```js
"use strict";
var result = eval("var x=10, y=11; x+y");
alert(result); //21
```

这里在 `eval()`中声明了变量 x 和 y，然后将它们加在一起，返回了它们的和。于是，result 变
量的值是 21，即 x 和 y 相加的结果。而在调用 `alert()`时，尽管 x 和 y 已经不存在了，`result` 变量
的值仍然是有效的。

### new Function

#### 什么是函数

一个通俗的说法就是：函数简单的说就是重复执行的代码块。函数是这样的一段 JavaScript 代码，它只定义一次，但可能被执行或调用任意次。

#### 函数的定义

- 函数声明式定义 `function student(){}`
  这种定义方式，会将函数声明提升到该函数所在作用域的最开头，也是就无论你在这个函数的最小作用域的那儿使用这种方式声明的函数，在这个作用域内，你都可以调用这个函数为你所用

* 函数表达式 `var student = function(){}`
  此方式定义的函数，只能在该作用域中，这段赋值代码执行之后才能通过 fun（）调用函数，否则，由于变量声明提升，fun === undefined

- new Function 形式 `var student = new Function(arg1 , arg2 ,arg3 ,…, argN , body)`
  Function 构造函数所有的参数都是字符串类型。除了最后一个参数, 其余的参数都作为生成函数的参数即`形参`。这里可以没有参数。最后一个参数, `表示的是要创建函数的函数体`。

### 总结

- 第一种和第二种函数的定义的方式其实是第三种`new Function` 的语法糖，当我们定义函数时候都会通过 `new Function` 来创建一个函数，只是前两种为我们进行了封装，我们看不见了而已，js 中任意函数都是 Function 的实例。
- ECMAScript 定义的 函数实际上是功能完整的对象。
- 函数提升优先级高于变量提升，且不会被同名变量声明时覆盖，但是会被变量赋值后覆盖，即函数声明变量 init 时，优先级高于其他变量，并置于作用域最顶
- 函数私有变量优先级高于全局变量，并且函数私有变量仅在该函数体中有效，一般不影响全局作用域

### 避免双重解释

当 JavaScript 代码想解析 `JavaScript` 的时候就会存在`双重解释`惩罚。当使用 `eval()`函数或者是
`Function 构造函数`以及使用 `setTimeout()`传一个字符串参数时都会发生这种情况。下面有一些例子：

```js
//某些代码求值——避免!!
eval("alert('Hello world!')");
//创建新函数——避免!!
var sayHi = new Function("alert('Hello world!')");
//设置超时——避免!!
setTimeout("alert('Hello world!')", 500);
```

在以上这些例子中，都要解析包含了 `JavaScript` 代码的`字符串`。这个操作是`不能`在初始的解析过程
中完成的，因为代码是包含在`字符串中`的，也就是说在 JavaScript 代码运行的同时必须新启动一个解
析器来解析新的代码。实例化一个新的解析器有不容忽视的`开销`，所以这种代码要比直接解析慢得多。
对于这几个例子都有另外的办法。只有极少的情况下 `eval()`是绝对必须的，所以尽可能避免使用。
在这个例子中，代码其实可以直接内嵌在原代码中。对于`Function`构造函数，完全可以直接写成一般
的函数，调用 `setTimeout()`可以传入函数作为第一个参数。以下是一些例子：

```js
//已修正
alert("Hello world!");
//创建新函数——已修正
var sayHi = function() {
  alert("Hello world!");
};
//设置一个超时——已修正
setTimeout(function() {
  alert("Hello world!");
}, 500);
```

如果要提高代码性能，尽可能避免出现需要按照 `JavaScript` 解释的字符串。
